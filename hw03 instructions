// Problem 1: initializeStrings (5 points)
// Use pointer p to traverse the 2D array of characters variable 'strings' (input 
//from user in main() ) and set all characters in each
// array to a null terminator so that there is a 4 row and 50 column 2D array full 
//of null terminators.
// The null terminator '\0' is used to denote the end of a string.
void initializeStrings(char strings[NUM_STRINGS][STRING_LENGTH])
{
char *p = &strings[0][0];
// enter code here
}
// Problem 2: printStrings (5 points)
// Use pointer p to traverse the 2D character array "strings" and print each 
//string.
// See the example outputs provided in the word document. Each string should be 
//printed on a new line.
void printStrings(char strings[NUM_STRINGS][STRING_LENGTH])
{
char *p = &strings[0][0];
// enter code here
}
// Problem 3: reverseOneString (15 points)
// Reverse the string s by using pointer.
// Use pointer p and 'temp' char to swap 1st char with last, then 2nd char with 
//(last-1) and so on..
// Finally return pointer p which points to start of the reversed string.
// You may declare and use more pointers if needed.
// Hint: You might want to check if your logic works with even as well as odd 
//length string.
//       You can write test code to print out the reversed string to check if your 
function works. (Don't include it in final submission)
char* reverseOneString(char s[STRING_LENGTH])
{
char temp; // not necessary to use this variable
char *p = &s[0]; // pointer to start of string
// enter code here
return p;
}
// Problem 4: reverseStrings (5 points)
// Reverse all the strings in 'strings[][]'
// For each string in 'strings', use the reverseOneString() to reverse it.
// You may declare and use more pointers if needed.
void reverseStrings(char strings[NUM_STRINGS][STRING_LENGTH])
{
char *p = &strings[0][0];
// enter code here
}
// Problem 5: encryptStrings (5 points)
// Use pointer ptr to traverse the 2D character array 'strings' and encrypt each 
//string in 2 step as follows- 
// 1) Reverse the strings. Hint: Use 'reverseStrings()' for this step.
// 2) Shift the characters forward by the integer value of 'key'.
// If the string is "hello" and key = 2, reversing will get you "olleh" and adding 
//key to it will result in "qnngj".
// Once the value of 'key' gets larger, you will extend past alphabetical 
//characters and reach non-alphabetical characters. Thats ok.
// NOTE: DO NOT encrypt the null terminator character. Use the null terminator to 
//find the end string.
// If you could not implement reverseStrings(), skip using it in this 
//function. You will receive partial credit.
void encryptStrings(char strings[NUM_STRINGS][STRING_LENGTH], int key)
{
char *p = &strings[0][0];
// enter code here
}
// Problem 6: decryptStrings (5 points)
// HINT: This should be very similiar to the encryption function defined above in 
//encryptStrings().
// Use pointer p to traverse the 2D character array 'strings' and decrypt each 
//string in 2 step as follows- 
// 1) Shift the characters backward by the integer value of 'key'.
// 2) Reverse the strings. Hint: Use 'reverseStrings()' for this step.
// NOTE: DO NOT decrypt the null characters.
// If you could not implement reverseStrings(), skip using it in this 
//function. You will receive partial credit.
void decryptStrings(char strings[NUM_STRINGS][STRING_LENGTH], int key)
{
char *p = &strings[0][0];
// enter code here
}
// Problem 7: isPalindrome (10 points)
// Return 1 if string s is palindrome.
// Parse through the string to check if 1st char==last char, 2nd char == (last-1) 
//char, and so on..
// Return 1 if string is palindrome. Return 0 if string is not palindrome.
// A palindrome is a sequence of characters which when reversed, is the same 
//sequence of characters.
// Palindrome string examples: rotor, noon, madam
// Note: you may use reverseOneString() here but it is not necessary to use it. 
int isPalindrome(char s[STRING_LENGTH])
{
char *p = s;
int palindrome = 1; // edit if needed
// enter code here
return palindrome;
}
